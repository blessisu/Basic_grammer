# 완전 검색 (Brute-force / Exhaustive Search)

#### Baby-Gin

0~9 사이의 카드에서 임의의 카드 6장 뽑았을 때,

- 3장의 카드가 연속적인 번호를 갖는 경우 Run
- 3장의 카드가 동일한 번호를 갖는 경우 Triplete
- 6장의 카드가 Run, Triplete으로만 구성된다면 Baby-Gin

ex) 054060 은 000 (Triplete) 456(Run) 이므로 Baby-Gin

101123 은 111 (Triplete) 023 은 아무것도 아님

123 (run) 혹은 012 (run) 하더라도 남은게 아무것도 아니므로 -> Baby-Gin 아님



----> 6자리 숫자를 입력받아 Baby-Gin을 판단하는 알고리즘 어떻게? ==완전검색==



> 완전검색

- 문제의 solution을 얻기 위해 가능한 모든 경우를 나열하고 확인하는 방법
- 문제를 해결하기위한 간단하고 쉬운 접근법. (비교적 빠른 시간에 문제 해결 가능단, 알고리즘 = 가능한 빨리 답찾는것X)
- 대부분의 문제에 적용 가능
- 문제의 크기가 "작을 때" (검색해봐야할 가능한 모든 경우의 수가 작을 때) 유용



> 완전검색기법

특정 key 값을 표현하고 있는지 확인하고 싶을 때 사용가능한 방법

1. Sequential Search (순차 검색, 고지식한 검색)

   - 키 값을 찾기 위해 리스트의 첫 번째 자료부터 비교하면서 진행

   - 주로 탐색 성공 시 index 반환, 탐색 실패 시 -1 반환 

   - 단, 최악의 경우 [리스트에 키 값이 존재하지 않은 경우] -> 모든 리스트를 모두 탐색해야 함

   - 가장 단순한 방법이기 때문에, 문제의 크기가 크면 시간 복잡도가 매우 크게 증가. 그러나 모든 걸 살펴보기 때문에 수행 속도는 느리지만 solution 찾을 확률이 높음

     --> 그리디 기법, 동적 계획법을 보다 효율적으로 사용

   - 주로 알고리즘 효율성을 평가/판단하는 척도로 사용함

     --> 완전 탐색 사용하여 답을 확인한 후 성능 개선을 위해 다른 효육적 방법을 찾는 것이 바람직함



> 다시 Baby-Gin

1. 고려할 수 있는 모든 경우의 수 생성

   {2, 3, 5, 7, 7, 7} 을 받았을 경우 가능한 모든 경우의 순열 나열

   {2, 3, 5, 7, 7, 7} {2, 3, 7, 7, 7, 5} {2, 3, 7, 7, 5, 7} …

2. (모든 경우의 수에서)

   앞의 세 자리와 뒤의 세 자리를 잘라서 Run/Triplet 판단 후 Baby-Gin 판단

- 단 모든 경우의 수를 순열로 생성 시 중복된 작업을 수행하게됨

  --> 따라서 이 중복을 제거할 수 있다면 시간 단축 가능!

  --> 이미 확인했던 건 저장해놓자 --> memoization



> Memoization (메모이제이션) ?

- 동일한 계산을 반복해야할 때, 이전에 계산한 값을 메모리에 저장함으로써 동일한 계산의 반복 수행을 제거하여 실행 속도를 빠르게 하는 기술.