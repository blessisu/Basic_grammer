# 탐욕 알고리즘 (Greedy Algorithm)

### 탐욕 알고리즘

==최적화== 문제를 해결하는 알고리즘

최대값이나 최솟값 같은 ==최적해==를 구하고자할 때 사용함.

단, 해당 문제에 해가 여러 개 있을 수 있는데 단 하나의 최적해를 구할 때 사용함

보통 머리 속에 떠오르는 생각을 바로 구현 하는 경우, Greedy Algorithm 이 될 확률이 높음

- 선택 시 마다 최적이라고 생각되는 것을 선택하여 최종답에 도달

- 한 번 선택된 것은 번복 XX

- but, 선택은 "선택할 시"에 최적 값이지, 최종 답이 최적이 아닐 수 있음

  --> 고로 greedy algorith이 항상 "최적해"를 보장하는 지는 검증해봐야 함.

#### 동작 과정

1. 현재 상태에서 부분 문제의 최적해를 구한 뒤, 부분 해 집합(Solution Set)에 추가

2. 하나의 선택이 이루어지면 새로운 부분 문제 발생 

3. 새로운 부분 문제는 실행 가능한가? 문제의 제약 조건에 위반되지는 않는가?

   --> 위반한다면 다른 해를 선택했어야 함

4. Solution Set이 문제의 해가 되는 지 확인 후, 안된다면 1 선택부터 다시 시작



### 예시 문제

#### 동전 거스름돈 문제

> 손님이 지불한 금액에서 물건값을 제한 차액(거스름돈)을 지불하자.
>
> 단 "지페와 동전의 개수"를 "최소한"으로

1. 해 선택 

   가장 좋은 해 선택 --> 단위가 큰 동전으로만 거스름 돈을 만들면, 동전 개수가 줄어들기 때문에 현재 고를 수 있는 가장 단위가 큰 동전 골라 거스름돈에 추가

2. 실행 가능성

   거스름돈 액수가 초과하는 지 확인

   - 초과할 경우 : 마지막 추가한 동전 거스름돈에서 빼고, 해 선택 과정으로 돌아가서 현재보다 작은 단위의 동전 추가

3. 해 검사

   거스름돈 문제의 해 == 손님에게 내드려야 하는 거스름돈의 액수 인지 확인

   액수가 모자랄 경우? --> 다시 1로 돌아가서 거스름돈에 추가할 동전 선택

> 실제 과정 (650원을 걸러줘야 할 때, 500, 100, 50, 10원 사용)

1. 500 -> 500 

   실행가능성) 총 합 1000원으로 불가능!

   --> 500원을 다시 빼주고 작은 값인 100을 고르기

2. 500 -> 100

   실행가능성) 총 합 600으로 가능, 그러나 아직 부족하므로 해 선택 다시 시작

3. 500 -> 100 -> 100

   실행 가능성) 총합 700으로 불가능, 다시 빼주고 더 작은 값고르기

4. 500 -> 100 -> 50

   실행 가능성) 총합 650으로 가능, 게다가 거스름돈 액수와 일치 == 최적해!

> 만약 위 과정이 (650원을 걸러줘야 할 때, 500, 300, 100, 50, 10원 사용) 이었다면?

300원을 선택할 일이 없으므로, 300,300,50 이 실제 답이지만 Greedy Algorithm 으로는 최적해를 찾을 수 없음!!

- 즉 답을 찾았다고 그것이 최적해라는 보장이 없음. 만약 최적해를 구한다는 보장을 하려면, 알고리즘 검증 작업이 필요!

> 그렇다면 어떻게 ?

- 이 경우 "완전 탐색"을 통해 모든 경우를 살펴보되, 음수가 되면 stop 하고 0이 되면 최적해 가능성이 있음
- 가능성이 있는 최적해 중에, 간선의 수가 최소인 경우가 최적해



#### 배낭 문제 / 냅색 / Knapsack

> 도둑들이 부자들의 물건을 훔치기 위해 창고에 들어가는데, 
>
> 배낭에 넣을 수 있는 개수를 넘지 않으면서, 가장 이득을 보게 훔치려면?

- 배낭의 최대 무게 W
- 부자의 물건은 각각 물건 i에 대해 무게 `a[i][w]`, 값 `a[i][price]` 고정



##### 0-1 (Zero-One) Knapsack

> 배낭에 물건을 통째로 담아야하는 문제

- 물건을 쪼갤 수 없는 경우

  

> 완전 검색 방법

1. 완전 검색으로 물건의 모든 부분집합을 구한다.
2. 부분집합의 총 무게가 W를 초과하지 않으면서, 값이 가장 큰 집합 선택
3. 물건의 개수가 증가하면 시간 복잡도가 지수적으로 증가함을 주의 : O(2^n^)



> 탐욕적 방법 

1. 값이 비싼 물건부터 채우기 : **불가능**

```python
a = [[25, 13], [10, 10], [9, 8]] # 무게, 가격 순
W = 25
```

- 탐욕적 방법으로 찾은 해 : [25, 13] --> 13만원
- 실제해 : [10, 10] [9, 8] --> 18만원

2. 무게가 가벼운 물건 부터 채우기 : **불가능**

```python
a = [[25, 20], [10, 10], [9, 8]] # 무게, 가격 순
W = 25
```

- 탐욕적 방법으로 찾은 해 : [10, 10] [9, 8] --> 18만원
- 실제해 : [25, 20] --> 20만원

3. 무게당 가치(가격/무게) 값이 높은 순서로 물건 채우기 : **불가능**

```python
a = [[5, 50], [10, 60], [20, 140]]
W = 30
a_price_per_kg = [50/5, 60/10, 140/20] = [10, 6, 7]
```

- 탐욕적 방법으로 찾은 해 : 10 [5, 50]  7 [20, 140] --> 190만원 
- 실제해 : 6 [10, 60] 7 [20, 140] --> 200만원



--> 즉 냅색 문제는, greedy algorithm으로 찾기 어렵고 완전 검색을 사용해야 함



##### Fractional Kanpsack

> 물건을 부분적으로 담는 것이 허용되는 문제

- 물건을 쪼갤 수 있는 경우

1. 무게당 가치(가격/무게) 값이 높은 순서로 물건 채우기 : **가능**

```python
a = [[5, 50], [10, 60], [20, 140]]
W = 30
a_price_per_kg = [50/5, 60/10, 140/20] = [10, 6, 7]
```

- 가성비가 가장 좋은 10을 선택 [5, 50] --> 5kg / 50만원

- 그다음 가성비가 좋은 7을 선택 [20, 140] --> 25kg / 190 만원

- 그다음 가성비가 좋은 6을 선택 [10, 60]

  --> 여기서 5kg 만 필요하므로 5kg 30만원만 사용 --> 30kg / 220 만원

  220 만원이 최적해 [이상적으로 구할 수 있는 최대 가치] but 실제 해X



#### 활동 선택 문제

> 시작 시간과 종료 시간이 있는 n개의 활동집합 
>
> activity = {(start~1~, end~1~), ...(start~n~, end~n~)} 에서
>
> 서로 겹치지 않는(Non-overlapping) 최대 개수의 활동들의 집합 구하는 문제

- 양립 가능한 활동들의 크기가 최대가 되는 부분집합을 선택하는 문제

- 종료 시간 기준으로 정렬

  

##### 회의실 배정 문제

> 사용 가능한 회의실 하나 존재, 신청된 회의들은 시작시간 종료시간 존재.
>
> 가장 많은 회의를 배정하자

--> Greedy Algorithm 사용하여 찾을수 있음!

1. 종료 시간으로 정렬
2. 종료 시간이 가장 빠른 것 선택 `S0~n = a1 + S1~n`
3. S1~n 에 대해 풀이 --> a1의 종료 시간보다 늦게 시작하면서 가장 앞에 있는 원소(종료 시간은 가장 빠른)

- 즉 매 선택마다, 종료시간이 가장 빠른 것을 선택한 다음, 크기가 작아진 부분집합에서 해당 선택을 재실행하므로 Greedy 탐색임 (locally optimal choice)

  

- 재귀로 구현한 탐욕 기법 

```python
A = [a1, a2.... an] # 종료 시간으로 정렬된 회의 list
S = [] # 선택된 활동들을 append 할 list

Recursive_Selection(i, j):
    m = i+1
    while m <= j and sm < fi: 
    # 시작시간이 선택된 것의 종료시간보다 빠르면 그 다음 것을 살펴 보자
        m = m + 1
    if m <= j:
        # 가능한 가장 빠른 활동 + 다음 선택의 부분집합
        return {am} U Recursive_Selection (m,j)
    else:
        # 선택된 해가 없으면 공집합
        return {} # 공집합
```



### 탐욕 알고리즘은 최적해를 보장하는가?

#### 탐욕적 선택 속성(Greedy choice property)

- 탐욕적 선택은 항상 안전하다는 것, 최적해로 갈 수 있다는 것을 증명해야함
- 종료 시간이 가장 빠른 활동을 선택하는 것은 "항상 안전"

#### 최적 부분 구조(Optimal substructure property)

- `원문제의 최적해 = 탐욕적 선택 + 하위 문제의 최적해` 로 정형화 됨을 증명



### 탐욕 기법 VS 동적 계획법

|                          탐욕 기법                           |                     동적 계획법                      |
| :----------------------------------------------------------: | :--------------------------------------------------: |
| 매 단계에서 가장 좋아보이는 것 선택<br />지역 최적 선택(local optimal choice) | 매 단계의 선택은 해결한 하위 문제의 해를 기반으로 함 |
|           탐욕 선택이 먼저<br />그 다음 하위 문제            |                   하위 문제가 먼저                   |
|                        Top-down 방식                         |                    Bottom-up 방식                    |
|                       보통 빠르고 간결                       |                   보통 느리고 복잡                   |



### Baby-Gin : using Greedy

> 완전 탐색이 아닌 Greedy Algorithm으로 baby-gin을 풀어보자

1. 6개의 숫자는 6자리 정수로 입력되며 카운트 리스트에 저장

   - 카운트 리스트? : 0 ~ 9 까지 숫자의 빈도수를 저장하는 리스트

2. 카운트 리스트의 각 원소를 체크하며 Run과 Triplet 및 Baby-Gin 판단

   Greedy - Algorithm 적용

   1. 카운트 리스트에서 Run, Triplet 중에 가능한 것 조사
   2. 조사에 사용한 데이터 삭제
   3. 남은 데이터를 Run과 Triplet 중에 가능한 지 조사

   - 단 ==triplet 을 먼저 검사==할 것. Run을 먼저 검사할 경우 [3,1,1,1,0,0,0,0,0,0] 의 경우 [2,0,0,1,0,0,0,0,0,0] 가 되어 error



### 대표적인 탐욕 기법 알고리즘

#### Prim [graph]

> N개의 정점으로 구성된 최소 신장 트리(MST)를 찾음

정점을 하나씩 선택하는 과정에서 트리를 확장하면서 MST를 찾음

#### Kruskal [graph]

> N개의 정점으로 구성된 최소 신장 트리(MST)를 찾음

싸이클이 없는 서브 그래프들을 확장하면서 MST를 찾음

#### Dijkstra [graph]

> 주어진 정점에서 다른 정점들에 대한 최단 경로 찾기

주어진 정점에서 가장 가까운 정점을 선택하면서, 출발점에서 다른 모든 정점들의 최단경로를 찾음.

#### Huffman coding [string]

> 문서의 압축을 위해 문자들의 빈도수에 따라 코드 값을 부여함

출현 빈도가 낮은 문자부터 선택해서 이진트리를 만들고 코드값을 부여

