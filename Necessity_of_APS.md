# SW 문제해결이란? 그리고 그의 필요성?

#### SW 문제 해결

> 요구사항 for programming

- 프로그래밍 언어의 특성
- 프로그램이 동작할 H/W와 OS에 관한 지식
- 라이브러리들의 유의 사항
- 프로그램이 사용할 수 있는 최대 메모리
- 사용자 대응 시간 제한
- 재사용성이 높은 간결한 코드

> SW 문제 해결 역량?

프로그램 작성을 위한 많은 제약 조건들과 요구 사항들을 이해하고 최선의 방법을 찾아내는 방법

- 언어, 라이브러리, 자료구조, 알고리즘에 대한 지식을 적재적소에 연결하여 큰 그림을 만드는 능력
- 무조건 암기하고 문제 푼다고 늘지 않음
- 새로운 언어, 프레임워크, 개발 방법론들을 적절히 조합하는 방법을 알아야함
- 경험 or 인위적인 상황을 만들어 "훈련"



> 문제 해결 과정

1. 문제를 읽고 이해
2. 익숙한 용어로 재정의
3. 어떻게 해결할지 계획 세우기
4. 계획 검증
5. 구현
6. 풀이를 다시보면서 개선 방안 찾기



> 문제 해결 전략 : 직관적으로 바로바로 해결 방법 떠오르지 않을 때도 있을 텐데

- ==직관==적이고 ==체계적==접근 하는 법
  1. 비슷한 문제를 풀어봤던가? : 그러기 위해선 여러 문제 부딪혀 봐야함
  2. 단순한 방법으로 시작할 수 있을까?
  3. 문제를 단순화 · 수식화 · 도식화할 수 있을까?
  4. 문제를 분해할 수 있을까?
  5. 뒤에서부터 생각해서 문제를 풀 수 있을까? : 사용되는 자료를 거꾸로 읽어보기
  6. 특정 형태의 답만을 고려할 수 있을까?





#### 알고리즘

> Algorithm

- 유한한 단계를 통해 문제를 해결하기 위한 절차나 방법
- 주로 컴퓨터가 어떤 일을 수행하기 위한 단계적 방법
- 단순히 1~n 까지의 합도 각각 더 해주는 방법과, (1+n)*n/2 로 구할 수도 있음

> 효율

- 같은 문제에 대한 다른 알고리즘들이 실행될 때, 알고리즘의 ==효율==에 따라 실행 시에 차이가 발생함.

- 알고리즘 설계 -> 실행에 필요한 자원 분석 -> 효율성 제시

  - 공간적 효율성 : 얼마나 많은 메모리 공간 필요?
  - 시간적 효율성 : 얼마나 많은 시간 필요?
  - 효율성 : Complexity 로 표현. Complexity가 높을 수록 효율성 감소

- 시간 복잡도

  - HW, SW 환경에 따라 처리 시간이 달라질 수 있음. 따라서 실행 시간으로는 판단하기 어렵다.

  - 따라서 Asymptotic Notation (점근적 표기)를 사용함

    - 입력 크기에 대한 함수를 다항식으로 표현
    - O(Big-Oh) 표기법, Ω(Big-Omega) 표기법, Θ(Theta) 표기법

    

#### 점근적 표기 (Asymptotic Notation)

1. O(Big-Oh) 표기

   - 복잡도의 점근적 상한
   - 다항식의 최고차항만 계수없이 취함
   - 따라서 f(n) = O(g(n)) 과 같은 표기를 보면 cg(n) 이 충분히 큰 n에 대해서는 f(n) 보다 항상 크다고 해석할 수 있음 (g(n)은 f(n)의 점근적 상한이니까)

2.  Ω(Big-Omega) 표기

   - 복잡도의 점근적 하한
   - 다항식의 최고차항만 계수없이 취함
   - f(n) = Ω(g(n)) 은 충분히 큰 n에 대해 f(n)이 cg(n) 보다 작을 수 없다를 뜻함
   - "최소한 이만큼의 시간은 걸린다"를 의미함

3. Θ(Theta) 표기

   - O(Big-Oh) 표기와 Ω(Big-Omega) 표기가 동일한 경우에 사용
   - f(n) = O(g(n)) = Ω(g(n)) 일 때, f(n) = Θ(g(n)) 이라고 표기할 수 있음
   - 충분히 큰 n에 대해 g(n)과 동일한 증가율을 가진다는 것을 의미함

   

> 자주 쓰는 Big-Oh 표기법

- O(1) : 상수 시간(Constant time)
- O(logn) : 로그 (대수) 시간 (Logarithmic time)
- O(n) : 선형 시간 (Linear time)
- O(nlogn) : 로그 선형 시간 (Log-linear time)
- O(n^2^) : 제곱 시간 (Quadratic time)
- O(n^3^) : 세제곱 시간 (Cubic time)
- O(2^n^) : 지수 시간 (Exponential time)



#### 효율적인 알고리즘이 필요한 이유?

10 억개의 숫자를 정렬할 때

O(n^2^) 알고리즘으로 정렬 시 300년이 걸린다고 할 때, (슈퍼컴퓨터의 경우 일주일)

O(nlong)의 알고리즘은 5분 만에 정렬 (슈퍼컴퓨터의 경우 1초)

- 즉 효율적인 알고리즘이란, 슈퍼 컴퓨터보다 큰 가치!
- 비싼 H/W 기술 개발보다 효율적인 알고리즘 개발이 더 경제적일 수 있음







